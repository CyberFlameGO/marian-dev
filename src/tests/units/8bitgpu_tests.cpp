#include "catch.hpp"
#include "graph/expression_graph.h"
#include "graph/expression_operators.h"

#ifdef CUDA_FOUND
#include "tensors/gpu/backend.h"
#endif

#include <cmath>

using namespace marian;

template <typename T>
void gemmTestTyped(Type floatType){
  auto graph = New<ExpressionGraph>(true);
  graph->setDefaultElementType(floatType);
  graph->setDevice({0, DeviceType::gpu});
  // setup for gemmPrecision "int8AlphaFused"
  graph->getBackend()->setInt8(true);
  graph->getBackend()->setFused(true);
  graph->getBackend()->setDumpQuantMult(true);
  graph->reserveWorkspaceMB(32);

  std::vector<T> values, values2;

  graph->clear();
  values.clear();

  std::vector<T> vA({83,40,-78,15,36,-13,-74,1,9,3,79,-73,-65,4,-56,-78,-14,-74,-42,70,5,-92,86,-20,27,-81,-12,65,93,-82,90,-72,77,72,-31,-87,-54,-24,-6,-14,67,-30,64,-41,-82,28,5,-1,15,36,67,26,29,78,39,-59,-44,68,-72,36,-72,-12,39,43,93,-89,93,-9,13,88,95,-35,-3,8,-59,-68,43,69,54,46,35,68,-44,80,-43,84,70,-11,53,15,50,51,-89,17,86,68,86,67,-89,56,24,-97,-66,-56,86,40,93,-63,28,17,-31,40,-8,-71,-58,-27,-5,-49,78,-81,65,49,0,-72,29,96,-18,-78,-51,82,-71,-38,82,54,-33,-60,6,96,-66,-25,76,24,42,11,-79,30,73,70,45,99,-99,29,-17,23,64,-93,-96,43,-36,-90,62,-38,-79,96,-86,32,-3,-69,-81,-82,24,-26,-57,-30,97,-95,-73,23,19,-19,67,-40,2,17,-76,-55,14,21,63,83,7,-99,-10,-33,84,5,-66,-24,17,-3,28,-54,87,-42,-87,-10,55,-39,-41,35,37,25,64,68,-8,71,-29,-49,-44,95,38,-1,-96,30,63,29,98,-16,-57,39,-48,-19,32,21,43,-71,-94,72,48,-22,26,-98,24,27,50,-88,56,-25,-71,55,-9,-63,-60,25,-89,5});
  std::vector<T> vB({20,-48,-1,36,-94,27,-75,32,-79,28,67,-14,-50,59,77,41,36,-1,96,7,1,50,85,55,67,89,46,25,48,51,0,69,-56,79,59,-55,13,84,-78,94,4,-28,68,52,56,35,-62,-74,-74,50,73,56,72,-42,-1,-96,-87,8,29,96,2,34,71,-68,22,-32,-87,79,21,20,-60,79,61,58,0,75,94,39,49,-39,-35,-29,-32,-82,-45,-76,-58,69,54,-2,-54,88,-3,-8,-11,-58,8,73,90,-13,-81,-78,-2,-27,26,-64,88,57,-1,-85,67,60,-84,31,-5,-88,99,-31,13,76,-41,-92,97,29,-57,27,88,17,-18,-19,26,48,21,96,-2,-50,44,53,-51,-64,-61,4,-8,-77,-42,30,-34,72,4,-19,90,-45,-98,-52,90,-40,-98,-71,95,61,24,33,-16,-41,39,-70,24,-40,-98,3,3,-86,-72,-51,43,-19,-63,-6,40,-91,-89,-16,90,42,6,33,-67,21,-97,64,44,9,-38,-40,-10,36,40,-8,-91,79,84,33,63,-40,0,-15,-71,90,-76,63,-16,-90,-33,72,81,-16,-79,-52,-3,4,-19,-71,90,-75,-100,99,76,42,5,-28,-81,93,-58,-10,-47,-72,-53,43,-18,96,-64,81,42,87,-72,-50,36,-95,-32,54,-8,-73,38,35,40,67});
  std::vector<T> vAff({25894,-21628,-20129,5396,12121,7229,5544,-9703,-14075,7090,907,-2092,-2650,-783,12590,-13578,-3235,-443,16337,12074,7085,-11179,-24199,4393,10349,1865,-5179,-1880,-8362,5799,-12295,14758,17811,-3372,4459,-4065,-11462,14135,11613,-7610,-7974,7008,-5405,-22500,-9117,-1678,3432,1594,-9968,13417,12896,5470,-22581,-4402,1263,5976,-1419,1698,527,20150,8105,7635,7181,2328,-17616,15861,3347,3409,-22996,-912,-36166,11800,-4690,-13496,13261,8392,6944,-8855,2990,-915,-17169,21925,29263,136,-19479,-18459,15924,-16231,-20876,5627,-9506,-309,-20074,4184,26210,4631,14228,-9800,-3821,37816,8253,12442,12491,-31785,-18828,25461,4978,-29068,-7062,259,15048,5138,11265,-3258,-12099,8692,-2767,10092,2636,-21047,-3592,-12413,2052,-11279,-7711,-34243,4207,-6967,-355,-9343,-11114,23752,-931,3491,4421,11838,20939,15571,-4750,-3139,8572,-4332,-4708,18307,1004,1768,-15974,-18546,32374,7069,2009,4806,-9544,-9824,-2569,25542,12864,-5263,111,-44967,7894,-2588,8860,-3573,-2559,-19825,-16903,-6786,-19919,-4414,-17602,5449,-7810,3442,-5804,-5,797,-766,-7513,-21139,14297,7929,-1229,26612,12616,-6493,2637,13709,12498,-5664,-6975,-5500,874,17462,13282,-13738,7815,2879,-8693,-4383,-16991,-11961,-4767,-7686,-5161,-3235,-8452,-16202,-8631,-7895,-2394,-20255,68,-2245,4753,17696,24301,6587,1856,30953,14396,14170,2429,-12193,-4652,13622,5923,-11236,-2276,18775,-2707,3128,-24044,-7215,508,-6606,-5613,-1394,1403,-18187,12059,5010,-14862,12021,-2332,-922,3568,-25531,-20117,-17507,19957,9837,11859,-16776,18347,-10277});

  auto A = graph->param("A", {16, 16}, inits::fromVector(vA));
  auto B = graph->param("B", {16, 16}, inits::fromVector(vB));
  auto C = graph->param("C", {1, 16}, inits::fromValue(0));

  auto aff = affine(A, B, C, false, false, 0.0f, false);
  auto aff2 = affine(A, B, nullptr, false, false, 0.0f, false);

  graph->forward();

  CHECK(aff->shape() == Shape({16, 16}));
  aff->val()->get(values);
  auto floatApprox = [](T x, T y) -> bool { return x == Approx(y).margin(0.001f); };
  std::cout<<"values[0]:"<< values[0]<<std::endl;

  CHECK(aff2->shape() == Shape({16, 16}));
  aff2->val()->get(values2);
  std::cout<<"values2[0]:"<< values2[0]<<std::endl;
//  CHECK(values[0] == vAff[0]);
//  CHECK(values==vAff);
}


#ifdef CUDA_FOUND
TEST_CASE("gpu fp32") {
  gemmTestTyped<float>(Type::float32);
}
#if COMPILE_FP16
TEST_CASE("gpu fp16") {
  std::cout<<"------------gpu fp16---------------"<<std::endl;
  gemmTestTyped<float16>(Type::float16);
}
#endif
#endif
